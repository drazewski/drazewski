{
    "componentChunkName": "component---src-templates-blog-js",
    "path": "/blog/how-to-use-let-and-const",
    "result": {"data":{"contentfulBlogPosts":{"date":"Sep 30, 2021","title":"Let and const - how to use them","content":{"raw":"{\"nodeType\":\"document\",\"data\":{},\"content\":[{\"nodeType\":\"heading-2\",\"content\":[{\"nodeType\":\"text\",\"value\":\"JS variables\",\"marks\":[],\"data\":{}}],\"data\":{}},{\"nodeType\":\"paragraph\",\"content\":[{\"nodeType\":\"text\",\"value\":\"There are three ways in JavaScript that one can declare a variable - \",\"marks\":[],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"var\",\"marks\":[{\"type\":\"bold\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\", \",\"marks\":[],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"let\",\"marks\":[{\"type\":\"bold\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\", and \",\"marks\":[],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"const\",\"marks\":[{\"type\":\"bold\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\". Before ECMAScript 2015 (ES6), we only had \",\"marks\":[],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"var\",\"marks\":[{\"type\":\"code\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\" declarations. Variables declared with \",\"marks\":[],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"var\",\"marks\":[{\"type\":\"code\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\" do not support block-level scope but are limited to function scope. It means that if a variable is declared with \",\"marks\":[],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"var\",\"marks\":[{\"type\":\"code\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\" in a loop or a block is also available outside the loop or if block. This is because they are hoisted.\\nVariables declared with the \",\"marks\":[],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"var\",\"marks\":[{\"type\":\"code\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\" keyword always have a function scope, which means that they recognize functions as having a separate scope. Therefore, this local scope variable is not available with global scope.\\nLet's see two examples:\",\"marks\":[],\"data\":{}}],\"data\":{}},{\"nodeType\":\"embedded-entry-block\",\"content\":[],\"data\":{\"target\":{\"sys\":{\"id\":\"liJobEKs8AFJ2q2VCIoZN\",\"type\":\"Link\",\"linkType\":\"Entry\"}}}},{\"nodeType\":\"embedded-entry-block\",\"content\":[],\"data\":{\"target\":{\"sys\":{\"id\":\"4IIQEzssMCpFLcdvUwmEH\",\"type\":\"Link\",\"linkType\":\"Entry\"}}}},{\"nodeType\":\"paragraph\",\"content\":[{\"nodeType\":\"text\",\"value\":\"\",\"marks\":[],\"data\":{}}],\"data\":{}},{\"nodeType\":\"heading-2\",\"content\":[{\"nodeType\":\"text\",\"value\":\"Let and const\",\"marks\":[],\"data\":{}}],\"data\":{}},{\"nodeType\":\"paragraph\",\"content\":[{\"nodeType\":\"text\",\"value\":\"In ES6 we got two new ways to declare variables: \",\"marks\":[],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"let\",\"marks\":[{\"type\":\"bold\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\" and \",\"marks\":[],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"const\",\"marks\":[{\"type\":\"bold\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\". \",\"marks\":[],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"Let\",\"marks\":[{\"type\":\"code\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\" and \",\"marks\":[],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"const\",\"marks\":[{\"type\":\"code\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\" differ significantly from the var declaration. First of all, they have a block, not a global scope, and they are not hoisted either. So let's see what the situation will look like for a \",\"marks\":[],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"let\",\"marks\":[{\"type\":\"code\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\" variable, for the example above:\",\"marks\":[],\"data\":{}}],\"data\":{}},{\"nodeType\":\"embedded-entry-block\",\"content\":[],\"data\":{\"target\":{\"sys\":{\"id\":\"VTJ4tc256wrWArXHEoAPc\",\"type\":\"Link\",\"linkType\":\"Entry\"}}}},{\"nodeType\":\"paragraph\",\"content\":[{\"nodeType\":\"text\",\"value\":\"As you can see variable declared with \",\"marks\":[],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"let\",\"marks\":[{\"type\":\"code\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\" is only available inside \",\"marks\":[],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"if(){ ... }\",\"marks\":[{\"type\":\"code\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\" \",\"marks\":[{\"type\":\"bold\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"block and only after its declaration, not before. \",\"marks\":[],\"data\":{}}],\"data\":{}},{\"nodeType\":\"paragraph\",\"content\":[{\"nodeType\":\"text\",\"value\":\"Another important feature that distinguishes var from \",\"marks\":[],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"const\",\"marks\":[{\"type\":\"code\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\" and \",\"marks\":[],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"let\",\"marks\":[{\"type\":\"code\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\" is that it could be redeclared and \",\"marks\":[],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"const\",\"marks\":[{\"type\":\"code\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\" and \",\"marks\":[],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"let\",\"marks\":[{\"type\":\"code\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\" could not. The only difference between \",\"marks\":[],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"const\",\"marks\":[{\"type\":\"code\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\" and \",\"marks\":[],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"let\",\"marks\":[{\"type\":\"code\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\" is that one assigned value to a variable using const can not be reassigned with a new value. \",\"marks\":[],\"data\":{}}],\"data\":{}},{\"nodeType\":\"paragraph\",\"content\":[{\"nodeType\":\"text\",\"value\":\"And that's basically all you need to know about \",\"marks\":[],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"const\",\"marks\":[{\"type\":\"code\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\" and \",\"marks\":[],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"let\",\"marks\":[{\"type\":\"code\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\" variables. However, there are times when we want to use both types of variables and this is where problems sometimes arise.\",\"marks\":[],\"data\":{}}],\"data\":{}},{\"nodeType\":\"heading-2\",\"content\":[{\"nodeType\":\"text\",\"value\":\"Mix let and const when destructing\",\"marks\":[],\"data\":{}}],\"data\":{}},{\"nodeType\":\"paragraph\",\"content\":[{\"nodeType\":\"text\",\"value\":\"Destructuring\",\"marks\":[{\"type\":\"bold\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\" is a convenient way to extract multiple values from data stored in (possibly nested) objects and arrays and it can be used in locations that receive data (such as the left-hand side of an assignment).\",\"marks\":[],\"data\":{}}],\"data\":{}},{\"nodeType\":\"paragraph\",\"content\":[{\"nodeType\":\"text\",\"value\":\"I remember one interesting case when I was still a very novice javascript developer related to mixing \",\"marks\":[],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"let\",\"marks\":[{\"type\":\"code\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\" nad \",\"marks\":[],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"const\",\"marks\":[{\"type\":\"code\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\" declarations. I wanted to use \",\"marks\":[],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"let\",\"marks\":[{\"type\":\"code\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\" instead of \",\"marks\":[],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"const\",\"marks\":[{\"type\":\"code\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\", but \",\"marks\":[],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"eslint\",\"marks\":[{\"type\":\"italic\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\" was throwing me the error: \",\"marks\":[],\"data\":{}}],\"data\":{}},{\"nodeType\":\"paragraph\",\"content\":[{\"nodeType\":\"text\",\"value\":\"\\\"\",\"marks\":[],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"use const because this variable is never reassigned\",\"marks\":[{\"type\":\"italic\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\".\\\"\",\"marks\":[],\"data\":{}}],\"data\":{}},{\"nodeType\":\"paragraph\",\"content\":[{\"nodeType\":\"text\",\"value\":\"This is because \",\"marks\":[],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"let\",\"marks\":[{\"type\":\"code\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\" assumes that the variable value will be changed at some point of execution but it was not happening for some of these variables in my code.\",\"marks\":[],\"data\":{}}],\"data\":{}},{\"nodeType\":\"paragraph\",\"content\":[{\"nodeType\":\"text\",\"value\":\"In fact, I wanted to use \",\"marks\":[],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"const\",\"marks\":[{\"type\":\"code\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\" for some elements and \",\"marks\":[],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"let\",\"marks\":[{\"type\":\"code\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\" for others. Then, thanks to the kindness of a more experienced developer colleague, I got to know a method called \",\"marks\":[],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"elision\",\"marks\":[{\"type\":\"bold\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\". Elision allows you to use the \\\"holes\\\" syntax to omit array elements from destructuring:\",\"marks\":[],\"data\":{}}],\"data\":{}},{\"nodeType\":\"embedded-entry-block\",\"content\":[],\"data\":{\"target\":{\"sys\":{\"id\":\"OnLqRrbv0FbmyrCBN0uyY\",\"type\":\"Link\",\"linkType\":\"Entry\"}}}},{\"nodeType\":\"paragraph\",\"content\":[{\"nodeType\":\"text\",\"value\":\"If more than one trailing comma is used, an \",\"marks\":[],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"elision\",\"marks\":[{\"type\":\"bold\"},{\"type\":\"italic\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\" \",\"marks\":[{\"type\":\"italic\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"(or hole) is produced. An array with holes is called \",\"marks\":[],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"sparse\",\"marks\":[{\"type\":\"italic\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\" (a \",\"marks\":[],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"dense\",\"marks\":[{\"type\":\"italic\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\" array has no holes). \",\"marks\":[],\"data\":{}}],\"data\":{}},{\"nodeType\":\"paragraph\",\"content\":[{\"nodeType\":\"text\",\"value\":\"There is one more very interesting way to solve the above problem. As you probably know, almost everything is an object in javascript. Certainly, arrays are also objects. Therefore, the destructuring example above can be written as follows:\",\"marks\":[],\"data\":{}}],\"data\":{}},{\"nodeType\":\"embedded-entry-block\",\"content\":[],\"data\":{\"target\":{\"sys\":{\"id\":\"7H7ZVp8cZ9pe0C0DNERsQp\",\"type\":\"Link\",\"linkType\":\"Entry\"}}}},{\"nodeType\":\"paragraph\",\"content\":[{\"nodeType\":\"text\",\"value\":\"In general, the topic of destructuring in js is amazingly interesting and should be known by all developers working in this language. To all interested, I highly recommend a great source of knowledge with examples: \",\"marks\":[],\"data\":{}},{\"nodeType\":\"hyperlink\",\"content\":[{\"nodeType\":\"text\",\"value\":\"Exploringjs.com\",\"marks\":[],\"data\":{}}],\"data\":{\"uri\":\"https://exploringjs.com/es6/ch_destructuring.html#sec_more-array-destructuring\"}},{\"nodeType\":\"text\",\"value\":\".\",\"marks\":[],\"data\":{}}],\"data\":{}},{\"nodeType\":\"paragraph\",\"content\":[{\"nodeType\":\"text\",\"value\":\"\",\"marks\":[],\"data\":{}}],\"data\":{}}]}","references":[{"contentful_id":"liJobEKs8AFJ2q2VCIoZN","__typename":"ContentfulCodeBlock","description":"LET AND CONST: variable not defined","language":"javascript","code":{"code":"function doSomething() {\n    var foo = 'bar';\n\n    return foo + foo;\n}\n\nconsole.log(foo) //Error: foo is not defined"}},{"contentful_id":"4IIQEzssMCpFLcdvUwmEH","__typename":"ContentfulCodeBlock","description":"LET AND CONST: variable is undefined","language":"javascript","code":{"code":"function doSomethingWithX(x) {\n    console.log(foo) // foo is undefined because is hoisted inside function scope\n    if (x) {\n        var foo = x;\n    }\n\n    console.log(foo); // \"x\" value\n    return foo + 'bar';\n}"}},{"contentful_id":"VTJ4tc256wrWArXHEoAPc","__typename":"ContentfulCodeBlock","description":"LET AND CONST: let is not hoisted","language":"javascript","code":{"code":"function doSomethingWithX(x) {\n    console.log(foo) //Error: foo is not defined\n    if (x) {\n        console.log(foo) //ReferenceError: can't access lexical declaration`X' before initialization\n        let foo = x;\n\n        console.log(foo) // x\n    }\n\n    console.log(foo); //Error: foo is not defined\n    return foo + 'bar';\n}"}},{"contentful_id":"OnLqRrbv0FbmyrCBN0uyY","__typename":"ContentfulCodeBlock","description":"LET AND CONST: elision","language":"javascript","code":{"code":"const foo = ['a', 'b', 'c'];\n\nlet [a, b, c] = foo; //ESlint warning: use const because this variable is never reassigned\n\n----\n\nlet [ a ] = foo;\nconst [, b, c] = foo;\n// No warnings, a is decalred with let and b and c with const"}},{"contentful_id":"7H7ZVp8cZ9pe0C0DNERsQp","__typename":"ContentfulCodeBlock","description":"LET AND CONST: object destructing","language":"javascript","code":{"code":"let [a] = foo;\nconst {1: b, 2: c} = foo;"}}]},"featuredImage":{"fluid":{"srcSet":"//images.ctfassets.net/r1q8fbx9u30m/NKmKm4jeR3fYS6c1ACCn6/cb9b5fd25d0fe61797565b70c39f137b/owls-g38d02993f_1920.jpg?w=200&h=150&q=50 200w,\n//images.ctfassets.net/r1q8fbx9u30m/NKmKm4jeR3fYS6c1ACCn6/cb9b5fd25d0fe61797565b70c39f137b/owls-g38d02993f_1920.jpg?w=400&h=300&q=50 400w,\n//images.ctfassets.net/r1q8fbx9u30m/NKmKm4jeR3fYS6c1ACCn6/cb9b5fd25d0fe61797565b70c39f137b/owls-g38d02993f_1920.jpg?w=800&h=600&q=50 800w,\n//images.ctfassets.net/r1q8fbx9u30m/NKmKm4jeR3fYS6c1ACCn6/cb9b5fd25d0fe61797565b70c39f137b/owls-g38d02993f_1920.jpg?w=1200&h=900&q=50 1200w,\n//images.ctfassets.net/r1q8fbx9u30m/NKmKm4jeR3fYS6c1ACCn6/cb9b5fd25d0fe61797565b70c39f137b/owls-g38d02993f_1920.jpg?w=1600&h=1200&q=50 1600w,\n//images.ctfassets.net/r1q8fbx9u30m/NKmKm4jeR3fYS6c1ACCn6/cb9b5fd25d0fe61797565b70c39f137b/owls-g38d02993f_1920.jpg?w=1920&h=1440&q=50 1920w"}}}},"pageContext":{"slug":"how-to-use-let-and-const"}},
    "staticQueryHashes": ["2236985993","2543130515","63159454"]}